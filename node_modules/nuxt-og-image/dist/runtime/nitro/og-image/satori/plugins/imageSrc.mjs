import { withBase } from "ufo";
import sizeOf from "image-size";
import { defineSatoriTransformer } from "../utils.mjs";
import { toBase64Image } from "../../../../pure.mjs";
import { useNitroOrigin, useStorage } from "#imports";
export default defineSatoriTransformer([
  // fix <img src="">
  {
    filter: (node) => node.type === "img" && node.props?.src,
    transform: async (node, { e }) => {
      const src = node.props.src;
      const isRelative = src.startsWith("/");
      let dimensions;
      let imageBuffer;
      if (isRelative) {
        if (import.meta.prerender || import.meta.dev) {
          const key = `root:public${src.replace("./", ":").replace("/", ":")}`;
          if (await useStorage().hasItem(key))
            imageBuffer = await useStorage().getItemRaw(key);
        } else {
          imageBuffer = await e.$fetch(src, {
            baseURL: useNitroOrigin(e),
            responseType: "arrayBuffer"
          }).catch(() => {
          });
        }
      } else {
        imageBuffer = await $fetch(src, {
          responseType: "arrayBuffer"
        }).catch(() => {
        });
      }
      if (imageBuffer)
        imageBuffer = Buffer.from(imageBuffer);
      if (imageBuffer) {
        node.props.src = toBase64Image(src, imageBuffer);
        try {
          const imageSize = sizeOf(imageBuffer);
          dimensions = { width: imageSize.width, height: imageSize.height };
        } catch (e2) {
        }
      }
      if (dimensions?.width && dimensions?.height) {
        const naturalAspectRatio = dimensions.width / dimensions.height;
        if (node.props.width && !node.props.height) {
          node.props.height = Math.round(node.props.width / naturalAspectRatio);
        } else if (node.props.height && !node.props.width) {
          node.props.width = Math.round(node.props.height * naturalAspectRatio);
        } else if (!node.props.width && !node.props.height) {
          node.props.width = dimensions.width;
          node.props.height = dimensions.height;
        }
      }
      if (node.props.src.startsWith("/")) {
        node.props.src = `${withBase(src, `${useNitroOrigin(e)}`)}?${Date.now()}`;
      }
    }
  },
  // fix style="background-image: url('')"
  {
    filter: (node) => node.props?.style?.backgroundImage?.includes("url("),
    transform: async (node, { e }) => {
      const backgroundImage = node.props.style.backgroundImage;
      const src = backgroundImage.replace(/^url\(['"]?/, "").replace(/['"]?\)$/, "");
      const isRelative = src?.startsWith("/");
      if (isRelative) {
        if (import.meta.prerender || import.meta.dev) {
          const key = `root:public${src.replace("./", ":").replace("/", ":")}`;
          if (await useStorage().hasItem(key)) {
            const imageBuffer = await useStorage().getItemRaw(key);
            if (imageBuffer) {
              const base64 = toBase64Image(src, Buffer.from(imageBuffer));
              node.props.style.backgroundImage = `url(${base64})`;
            }
          }
        } else {
          node.props.style.backgroundImage = `url(${withBase(src, `${useNitroOrigin(e)}`)}?${Date.now()})`;
        }
      }
    }
  }
]);
